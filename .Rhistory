library(dsims)
devtools::test
install.packages("devtools")
devtools::test()
library(testthat)
devtools::load_all()
#Set up data
outer = matrix(c(0,0,0,500,2000,500,2000,0,0,0),ncol=2, byrow=TRUE)
hole1 = matrix(c(500,300,500,350,1500,350,1500,300,500,300),ncol=2, byrow=TRUE)
pol1 = list(outer, hole1)
mp = list(pol1)
mp1 = sf::st_multipolygon(mp)
region <- make.region(region.name = "main",
shape = mp1)
# Quick area calculation check
expect_equal(region@area, 2000*500-50*1000)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Test density surface creation
density <- make.density(region = region, x.space = 10, constant = 10)
expect_equal(all(density@density.surface[[1]]$density == 10), TRUE)
# Add hotspot
density <- add.hotspot(density, c(500,250), 200, 200)
# Fit a gam to the density surface
ddata <- density@density.surface[[1]]
fit.gam <- mgcv::gam(density~s(x,y), data = ddata)
# Try creating a density object from the gam results
density2 <- make.density(region, x.space = 10, density.gam = fit.gam)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Test density surface creation
density <- make.density(region = region, x.space = 10, constant = 10)
expect_equal(all(density@density.surface[[1]]$density == 10), TRUE)
# Add hotspot
density <- add.hotspot(density, c(500,250), 200, 200)
# Fit a gam to the density surface
ddata <- density@density.surface[[1]]
fit.gam <- mgcv::gam(density~s(x,y), data = ddata)
# Try creating a density object from the gam results
density2 <- make.density(region, x.space = 10, density.gam = fit.gam)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Test density surface creation
density <- make.density(region = region, x.space = 10, constant = 10)
expect_equal(all(density@density.surface[[1]]$density == 10), TRUE)
# Add hotspot
density <- add.hotspot(density, c(500,250), 200, 200)
# Fit a gam to the density surface
ddata <- density@density.surface[[1]]
fit.gam <- mgcv::gam(density~s(x,y), data = ddata)
# Try creating a density object from the gam results
density2 <- make.density(region, x.space = 10, density.gam = fit.gam)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Test density surface creation
density <- make.density(region = region, x.space = 10, constant = 10)
expect_equal(all(density@density.surface[[1]]$density == 10), TRUE)
# Add hotspot
density <- add.hotspot(density, c(500,250), 200, 200)
# Fit a gam to the density surface
ddata <- density@density.surface[[1]]
fit.gam <- mgcv::gam(density~s(x,y), data = ddata)
# Try creating a density object from the gam results
density2 <- make.density(region, x.space = 10, density.gam = fit.gam)
# This should work below
covariate.list <- list()
# Animal height is generated from a lognormal distribution for both strata
covariate.list$size <- list(distribution = "poisson", lambda = 25)
# Animal sex is discrete/categorical, there are more females than males in strata 1 and equal
# numbers in strata 2
covariate.list$sex <- data.frame(level = c("male", "female"), prob = c(0.5,0.5))
pop.descrp <- make.population.description(region = region,
density = density,
covariates = covariate.list,
N = 250)
cov.params <- list(size = log(1.05),
sex = data.frame(level = c("male", "female"),
param = c(log(1), log(1.5))))
expect_error(make.detectability(key.function = "zz",
scale.param = 5,
truncation = 25,
cov.param = cov.params),
"Unsupported key function, please select hn, hr or uf.")
cov.params <- list(size = log(1.05),
sex = data.frame(level = c("male", "female"),
param = c(log(1), log(1.5))),
height = NULL)
expect_error(make.detectability(key.function = "hn",
scale.param = 5,
truncation = 25,
cov.param = cov.params),
"List element height of the cov.param list does not contain any values.")
cov.params <- list(size = log(1.05),
sex = data.frame(factor = c("male", "female"),
param = c(log(1), log(1.5))))
expect_warning(expect_error(make.detectability(key.function = "hn",
scale.param = 5,
truncation = 25,
cov.param = cov.params),
"The dataframe for covariate 'sex' has missing columns: level"), "The dataframe for covariate 'sex' has unrecognised columns: factor. These will be ignored.")
cov.params <- list(size = log(1.05),
sex = data.frame(level = rep(c("male", "female"),2),
param = rep(c(log(1), log(1.5)),2),
strata = c("A", "A", "B", "B"),
ignore = rep(10,4)))
expect_warning(test <- make.detectability(key.function = "hn",
scale.param = 5,
truncation = 25,
cov.param = cov.params),
"The dataframe for covariate 'sex' has unrecognised columns: ignore. These will be ignored.")
tmp <- data.frame(level = rep(c("male", "female"),2),
param = rep(c(log(1), log(1.5)),2),
strata = c("A", "A", "B", "B"))
expect_equal(test@cov.param$sex, tmp)
cov.params <- list(size = log(1.05))
cov.params[[2]] <- data.frame(level = c("male", "female"),
param = c(log(1), log(1.5)))
expect_error(make.detectability(key.function = "hn",
scale.param = 5,
truncation = 25,
cov.param = cov.params),
"Not all the elements of the cov.param list are named. Please provide names for all elements.")
expect_warning(test <- make.detectability(key.function = "hn",
scale.param = 5,
shape.param = 1,
truncation = 25),
"You have selected the hn key function and supplied a shape parameter value, this will be ignored.")
expect_error(make.detectability(key.function = "hr",
scale.param = 5,
truncation = 25),
"You have selected the hazard rate model but not supplied a shape parameter.")
expect_error(make.detectability(key.function = "hr",
scale.param = 5,
shape.param = c(1,1.5),
truncation = 25),
"The same number of values must be provided for both the shape and scale parameters or only one value supplied for either the shape or scale parameter.")
cov.params <- list(size = log(1.05),
sex = data.frame(level = c("male", "female"),
param = c(log(1), log(1.5))))
detect <- make.detectability(key.function = "hn",
scale.param = 5,
truncation = 25,
cov.param = cov.params)
# Truncation checks
expect_error(make.ds.analysis(dfmodel = list(~1, ~size, ~size+sex),
key = rep("hn",3),
cutpoints = seq(0,25, length = 4),
truncation = "15%"),
"Truncation cannot be supplied as a percentage with binned data.")
expect_error(make.ds.analysis(dfmodel = list(~1, ~size, ~size+sex),
key = rep("hn",3),
cutpoints = seq(0,25, length = 4),
truncation = list(left="1",right="15%")),
"The first cutpoint must be 0 or the left truncation distance!")
expect_error(make.ds.analysis(dfmodel = list(~1, ~size, ~size+sex),
key = rep("hn",3),
cutpoints = seq(0,25, length = 4),
truncation = list(left="1",righ="15%")),
"Truncation must be supplied as a single number/string or a list with elements \"left\" and \"right\".")
expect_error(make.ds.analysis(dfmodel = list(~1, ~size, ~size+sex),
key = rep("hn",3),
cutpoints = seq(0,25, length = 4),
truncation = c("1","15%")),
"Truncation must be supplied as a single number/string or a list with elements \"left\" and \"right\".")
expect_error(make.ds.analysis(dfmodel = list(~1, ~size, ~size+sex),
key = c("hn","zz","uf"),
truncation = "5%"),
"All key function values should be either 'hn' or 'hr'.")
expect_error(make.ds.analysis(dfmodel = list(~1, ~size, ~size+sex),
key = c("hn","hr","hr"),
truncation = "5%",
criteria = "QIC"),
"This selection criteria is not currently supported, please select from 'AIC', 'BIC' or 'AICc'.")
expect_error(make.ds.analysis(dfmodel = list(~1, ~size, ~size+sex),
key = c("hn","hr","hr"),
truncation = "5%",
er.var = "ZZ",
criteria = "AIC"),
"The er.var argument must be one of: 'R2', 'R3', 'R4', 'S1', 'S2', 'O1', 'O2', 'O3', 'P2', 'P3'.")
analysis <- make.ds.analysis(dfmodel = list(~1, ~size, ~size+sex),
key = c("hn","hr","hr"))
design <- make.design(region = region,
transect.type = "line",
design = "systematic",
samplers = 20,
truncation = 25)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Test simulation creation
sim <- make.simulation(reps = 10,
design = design,
population.description = pop.descrp,
detectability = detect,
ds.analysis = analysis)
survey <- run.survey(sim)
plot(survey)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#Set up simulation
outer = matrix(c(0,0,0,500,2000,500,2000,0,0,0),ncol=2, byrow=TRUE)
hole1 = matrix(c(500,300,500,350,1500,350,1500,300,500,300),ncol=2, byrow=TRUE)
pol1 = list(outer, hole1)
mp = list(pol1)
mp1 = sf::st_multipolygon(mp)
region <- make.region(region.name = "main",
shape = mp1)
# Create density
density <- make.density(region = region, x.space = 10, constant = 10)
# Add hotspot
density <- add.hotspot(density, c(500,250), 200, 200)
# Population description
covariate.list <- list()
covariate.list$size <- list(distribution = "poisson", lambda = 25)
pop.descrp <- make.population.description(region = region,
density = density,
covariates = covariate.list,
N = 300)
cov.params <- list(size = log(1.02))
detect <- make.detectability(key.function = "hn",
scale.param = 30,
truncation = 100,
cov.param = cov.params)
# Make the design
design <- make.design(region = region,
transect.type = "point",
design = "systematic",
samplers = 30,
truncation = 100)
# Make analyses
analyses <- make.ds.analysis(dfmodel = ~1,
key = "hr",
truncation = 100,
er.var = "P2")
# Make.simulation
sim <- make.simulation(reps = 5,
design = design,
population.description = pop.descrp,
detectability = detect,
ds.analysis = analyses)
# Create a test survey
survey <- run.survey(sim)
plot(survey, region = region)
plot(survey, region)
library(dsims)
devtools::test()
expect_equal(class(survey@transect), "Point.Transect")
class(survey@transect)
class(survey@transect) == "Point.Transect"
devtools::test()
devtools::test()
test <- run.simulation(sim)
test@results
test@results$individuals
dim(test@results$individuals)
dim(test@results$individuals$N)
ls()
library(dsims)
shapefile.name <- system.file("extdata", "StAndrew.shp", package = "dssd")
region <- make.region(region.name = "St Andrews bay",
shape = shapefile.name)
plot(region)
# We first create a flat density grid
density <- make.density(region = region,
x.space = 500,
constant = 1)
# Now we can add some high and low points to give some spatial variability
density <- add.hotspot(object = density,
centre = c(-170000, 6255000),
sigma = 8000,
amplitude = 4)
density <- add.hotspot(object = density,
centre = c(-160000, 6275000),
sigma = 6000,
amplitude = 4)
density <- add.hotspot(object = density,
centre = c(-155000, 6260000),
sigma = 3000,
amplitude = 2)
density <- add.hotspot(object = density,
centre = c(-150000, 6240000),
sigma = 10000,
amplitude = -0.9)
density <- add.hotspot(object = density,
centre = c(-155000, 6285000),
sigma = 10000,
amplitude = -2)
plot(density, style = "blocks")
# First extract the data above - this is simple in this case as we only have a single strata
# Multi-strata regions will involve combining the density grids for each strata into a
# single dataset.
density.data <- density@density.surface[[1]]
head(density.data)
# Fit a simple gam to the data
fit.gam <- mgcv::gam(density ~ s(x,y), data = density.data, family = gaussian(link="log"))
# Use the gam object to create a density object
gam.density <- make.density(region = region,
x.space = 500,
density.gam = fit.gam)
plot(gam.density, style = "blocks")
# Create a covariate list describing the distribution of cluster sizes
covariates <- list(size = list(distribution = "ztruncpois", mean = 3))
# Define the population description
pop.desc <- make.population.description(region = region,
density = gam.density,
covariates = covariates,
N = 100,
fixed.N = TRUE)
parallel.design <- make.design(region = region,
design = "systematic",
spacing = 2500,
edge.protocol = "minus",
design.angle = 90,
truncation = 750)
zigzag.design <- make.design(region = region,
design = "eszigzag",
spacing = 2233,
edge.protocol = "minus",
design.angle = 0,
bounding.shape = "convex.hull",
truncation = 750)
set.seed(474)
p.survey <- generate.transects(parallel.design)
plot(region, p.survey)
z.survey <- generate.transects(zigzag.design)
plot(region, z.survey)
# Define the covariate parameters on the log scale
cov.param <- list(size = log(1.05))
# Create the detectability description
detect <- make.detectability(key.function = "hn",
scale.param = 400,
cov.param = cov.param,
truncation = 750)
# Plot the simulation detection functions
plot(detect, pop.desc)
analyses <- make.ds.analysis(dfmodel = list(~1, ~1, ~size),
key = c("hn", "hr", "hn"),
truncation = 750,
er.var = "R2",
criteria = "AIC")
sim.parallel <- make.simulation(reps = 999,
design = parallel.design,
population.description = pop.desc,
detectability = detect,
ds.analysis = analyses)
sim.zigzag <- make.simulation(reps = 999,
design = zigzag.design,
population.description = pop.desc,
detectability = detect,
ds.analysis = analyses)
# Generate a single instance of a survey: a population, set of transects
# and the resulting distance data
eg.parallel.survey <- run.survey(sim.parallel)
# Plot it to view a summary
plot(eg.parallel.survey, region = region)
# Generate a single instance of a survey: a population, set of transects
# and the resulting distance data
eg.parallel.survey <- run.survey(sim.parallel)
# Plot it to view a summary
plot(eg.parallel.survey, region)
# Generate a single instance of a survey: a population, set of transects
# and the resulting distance data
eg.parallel.survey <- run.survey(sim.parallel)
# Plot it to view a summary
plot(eg.parallel.survey, region)
# Generate a single instance of a survey: a population, set of transects
# and the resulting distance data
eg.zigzag.survey <- run.survey(sim.zigzag)
# Plot it to view a summary
plot(eg.zigzag.survey, region = region)
# Generate a single instance of a survey: a population, set of transects
# and the resulting distance data
eg.zigzag.survey <- run.survey(sim.zigzag)
# Plot it to view a summary
plot(eg.zigzag.survey, region)
# Generate a single instance of a survey: a population, set of transects
# and the resulting distance data
eg.zigzag.survey <- run.survey(sim.zigzag)
# Plot it to view a summary
plot(eg.zigzag.survey, region)
# Generate a single instance of a survey: a population, set of transects
# and the resulting distance data
eg.parallel.survey <- run.survey(sim.parallel)
# Plot it to view a summary
plot(eg.parallel.survey, region)
# Running the simulations
sim.parallel <- run.simulation(sim.parallel)
devtools::load_all()
debug(single.sim.loop)
sim.parallel <- run.simulation(sim.parallel)
class(survey)
sim.parallel <- run.simulation(sim.parallel)
tmp <-analyse.data(simulation@ds.analysis, survey)
survey
tmp <-analyse.data(simulation@ds.analysis, data.obj = survey)
class(survey)
class(survey)
class(simulation@ds.analysis)
library(dsims)
# Running the simulations
sim.parallel <- run.simulation(sim.parallel)
sim.zigzag <- run.simulation(sim.zigzag)
ls
()
ls()
getwd()
save(sim.parallel, file = "sim.parallel.ROBJ")
sim.zigzag <- run.simulation(sim.zigzag)
save(sim.zigzag, file = "sim.zigzag.ROBJ")
summary(sim.parallel
)
summary(sim.zigzag)
plot(sim.parallel)
hist(sim.parallel@results$individuals$N)
sim.parallel@results$individuals$N
dim.names(sim.parallel@results$individuals$N)
sim.parallel@results$individuals$N[1,1,]
hist(sim.parallel@results$individuals$N[1,1,])
summary(sim.parallel)
sim.parallel@results$Detection
library(dsims)
library(dsims)
library(dsims)
shapefile.name <- system.file("extdata", "StAndrew.shp", package = "dssd")
region <- make.region(region.name = "St Andrews bay",
shape = shapefile.name)
plot(region)
# We first create a flat density grid
density <- make.density(region = region,
x.space = 500,
constant = 1)
# Now we can add some high and low points to give some spatial variability
density <- add.hotspot(object = density,
centre = c(-170000, 6255000),
sigma = 8000,
amplitude = 4)
density <- add.hotspot(object = density,
centre = c(-160000, 6275000),
sigma = 6000,
amplitude = 4)
density <- add.hotspot(object = density,
centre = c(-155000, 6260000),
sigma = 3000,
amplitude = 2)
density <- add.hotspot(object = density,
centre = c(-150000, 6240000),
sigma = 10000,
amplitude = -0.9)
density <- add.hotspot(object = density,
centre = c(-155000, 6285000),
sigma = 10000,
amplitude = -2)
plot(density, style = "blocks")
# We first create a flat density grid
density <- make.density(region = region,
x.space = 500,
constant = 1)
# Now we can add some high and low points to give some spatial variability
density <- add.hotspot(object = density,
centre = c(-170000, 6255000),
sigma = 8000,
amplitude = 4)
density <- add.hotspot(object = density,
centre = c(-160000, 6275000),
sigma = 6000,
amplitude = 4)
density <- add.hotspot(object = density,
centre = c(-155000, 6260000),
sigma = 3000,
amplitude = 2)
density <- add.hotspot(object = density,
centre = c(-150000, 6240000),
sigma = 10000,
amplitude = -0.9)
density <- add.hotspot(object = density,
centre = c(-155000, 6285000),
sigma = 10000,
amplitude = -2)
plot(density)
install.packages("gridExtra")
library(dsims)
install.packages("testthat")
library(dsims)
library(dsims)
shapefile.name <- system.file("extdata", "StAndrew.shp", package = "dssd")
region <- make.region(region.name = "St Andrews bay",
shape = shapefile.name)
plot(region)
# We first create a flat density grid
density <- make.density(region = region,
x.space = 500,
constant = 1)
# Now we can add some high and low points to give some spatial variability
density <- add.hotspot(object = density,
centre = c(-170000, 6255000),
sigma = 8000,
amplitude = 4)
density <- add.hotspot(object = density,
centre = c(-160000, 6275000),
sigma = 6000,
amplitude = 4)
density <- add.hotspot(object = density,
centre = c(-155000, 6260000),
sigma = 3000,
amplitude = 2)
density <- add.hotspot(object = density,
centre = c(-150000, 6240000),
sigma = 10000,
amplitude = -0.9)
density <- add.hotspot(object = density,
centre = c(-155000, 6285000),
sigma = 10000,
amplitude = -1)
plot(density, region)
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("viridisLite")
library(dsims)
