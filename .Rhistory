summary(test)
summary(test$ddf)
ds.analysis <- make.ds.analysis(dsmodel = list(~size),
key = "hn",
truncation = 25)
ds.model <- analyse.data(ds.analysis, data.obj = survey)
test <- Distance::ds(survey@dist.data,
truncation = 25,
key = "hn"
formula = ~size)
ds.analysis <- make.ds.analysis(dsmodel = list(~size),
key = "hn",
truncation = 25)
ds.model <- analyse.data(ds.analysis, data.obj = survey)
test <- Distance::ds(survey@dist.data,
truncation = 25,
key = "hn",
formula = ~size)
ds.model$model$ddf
test$ddf
AIC(ds.model)$AIC
AIC(ds.model$model)$AIC
n <- length(ds.model$model$ddf$fitted)
k <- length(ds.model$model$ddf$par)
n
k
(2*k^2 + 2*k)/(n-k-1)
n <- 3:1000
test <- (2*k^2 + 2*k)/(n-k-1)
plot(test)
n <- 3:500
test <- (2*k^2 + 2*k)/(n-k-1)
plot(test, type= "l")
n <- 3:100
test <- (2*k^2 + 2*k)/(n-k-1)
plot(test, type= "l")
ds.analysis <- make.ds.analysis(dsmodel = list(~1, ~size, ~size+sex),
key = rep("hn",3),
truncation = 25)
ds.model.sel <- analyse.data(ds.analysis, data.obj = survey)
ds.model.sel
ds.model.sel$warnings
dist.data <- survey@dist.data
args <- list()
analysis <- ds.model.sel
if(!"transect" %in% names(args)){
#assume it is a line transect if it is missing
transect <- "line"
}else{
transect <- args$transect
}
transect
length(analysis@adjustment)
class(ds.model.sel)
ds.model.sel
analysis <- ds.analysis
if(length(analysis@adjustment) == 0){
adjustment <- NULL
order <- NULL
scale <- NULL
max.adjustments <- 0
}else{
adjustment <- analysis@adjustment$adjustment
order <- analysis@adjustment$order
scale <- analysis@adjustment$scale
max.adjustments <- analysis@adjustment$max.adjustments
}
transect
if("monotonicity" %in% names(analysis@control.opts)){
monotonicity <- analysis@control.opts$monotonicity
}else{
monotonicity <- ifelse(analysis@dsmodel == ~1, "strict", "none")
}
"monotonicity" %in% names(analysis@control.opts)
analysis@dsmodel
ifelse(analysis@dsmodel == ~1, "strict", "none")
analysis@dsmodel[[1]] == ~1
analysis@dsmodel[[2]] == ~1
analysis@dsmodel[[3]] == ~1
ifelse(analysis@dsmodel == ~1, "strict", "none")
ifelse(unlist(analysis@dsmodel) == ~1, "strict", "none")
unlist(analysis@dsmodel)
for(i in seq(along = analysis@dsmodel)){
monotonicity[i] <- ifelse(analysis@dsmodel[i] == ~1, "strict", "none")
}
monotonicity
if("method" %in% names(analysis@control.opts)){
method <- analysis@control.opts$method
}else{
method <- "nlminb"
}
method
analysis@truncation
if(length(analysis@truncation[[1]] == 1)){
truncation <- analysis@truncation[[1]]
}else{
truncation <- analysis@truncation
}
if(length(analysis@cutpoints) > 0){
# bin data
dist.data <- dist.data[dist.data$distance <= max(object@cutpoints),]
dist.data <- create.bins(dist.data, cutpoints = object@cutpoints)
}
models <- list()
IC <- numeric()
seq(along = analysis@dsmodel)
i = 1
# Set W to null
W <- NULL
# Try to fit model
models[[i]] <- suppressMessages(
withCallingHandlers(tryCatch(Distance::ds(data = dist.data,
truncation = truncation,
transect = transect,
formula = analysis@dsmodel[[i]],
key = analysis@key[i],
adjustment = adjustment[i],
order = order[i],
scale = scale[i],
cutpoints = NULL, #analysis@cutpoints,
monotonicity = monotonicity[i],
er.var = analysis@er.var,
method = method,
max.adjustments = max.adjustments[i]),
error=function(e)e),
warning=function(w){W <<- w; invokeRestart("muffleWarning")}))
#check if there was an error, warning or non-convergence
if(any(class(models[[i]]) == "error")){
warnings <- message.handler(warnings, paste("Error: ", models[[i]]$message, " (Model number: ", i, ")", sep = ""))
models[[i]] <- NA
}else if(models[[i]]$ddf$ds$converge != 0){
warnings <- message.handler(warnings, paste("The following model failed to converge: ", i, sep = ""))
models[[i]] <- NA
}else if(any(predict(models[[i]])$fitted < 0)){
warnings <- message.handler(warnings, paste("Negative predictions for model ", i,", excluding these results."), sep = "")
ddf.result <- NA
}
if(!is.null(W)){
warnings <- message.handler(warnings, paste(W, " (Model number: ", i, ")", sep = ""))
}
if(class(models[[i]]) == "dsmodel"){
IC[i] <- switch(analysis@criteria,
"AIC" = AIC(models[[i]])$AIC,
"BIC" = BIC(models[[i]]))
}
IC
models[[i]]$ddf
i=2
# Set W to null
W <- NULL
# Try to fit model
models[[i]] <- suppressMessages(
withCallingHandlers(tryCatch(Distance::ds(data = dist.data,
truncation = truncation,
transect = transect,
formula = analysis@dsmodel[[i]],
key = analysis@key[i],
adjustment = adjustment[i],
order = order[i],
scale = scale[i],
cutpoints = NULL, #analysis@cutpoints,
monotonicity = monotonicity[i],
er.var = analysis@er.var,
method = method,
max.adjustments = max.adjustments[i]),
error=function(e)e),
warning=function(w){W <<- w; invokeRestart("muffleWarning")}))
models[[2]]$call
analysis@dsmodel[[i]]
analysis@key[i]
adjustment[i]
adjustment[1]
order[i]
monotonicity[i]
max.adjustments[i]
models[[i]] <- suppressMessages(
withCallingHandlers(tryCatch(Distance::ds(data = dist.data,
truncation = truncation,
transect = transect,
formula = analysis@dsmodel[[i]],
key = analysis@key[i],
adjustment = adjustment[i],
order = order[i],
scale = scale[i],
cutpoints = NULL, #analysis@cutpoints,
monotonicity = monotonicity[i],
er.var = analysis@er.var,
method = method,
max.adjustments = max.adjustments),
error=function(e)e),
warning=function(w){W <<- w; invokeRestart("muffleWarning")}))
#check if there was an error, warning or non-convergence
models[[2]]$ddf
if(any(class(models[[i]]) == "error")){
warnings <- message.handler(warnings, paste("Error: ", models[[i]]$message, " (Model number: ", i, ")", sep = ""))
models[[i]] <- NA
}else if(models[[i]]$ddf$ds$converge != 0){
warnings <- message.handler(warnings, paste("The following model failed to converge: ", i, sep = ""))
models[[i]] <- NA
}else if(any(predict(models[[i]])$fitted < 0)){
warnings <- message.handler(warnings, paste("Negative predictions for model ", i,", excluding these results."), sep = "")
ddf.result <- NA
}
if(!is.null(W)){
warnings <- message.handler(warnings, paste(W, " (Model number: ", i, ")", sep = ""))
}
if(class(models[[i]]) == "dsmodel"){
IC[i] <- switch(analysis@criteria,
"AIC" = AIC(models[[i]])$AIC,
"BIC" = BIC(models[[i]]))
}
source('~/Documents/GitHub/dsims/dsims/R/AICc.R')
IC
i=3
# Set W to null
W <- NULL
# Try to fit model
models[[i]] <- suppressMessages(
withCallingHandlers(tryCatch(Distance::ds(data = dist.data,
truncation = truncation,
transect = transect,
formula = analysis@dsmodel[[i]],
key = analysis@key[i],
adjustment = adjustment[i],
order = order[i],
scale = scale[i],
cutpoints = NULL, #analysis@cutpoints,
monotonicity = monotonicity[i],
er.var = analysis@er.var,
method = method,
max.adjustments = max.adjustments),
error=function(e)e),
warning=function(w){W <<- w; invokeRestart("muffleWarning")}))
#check if there was an error, warning or non-convergence
if(any(class(models[[i]]) == "error")){
warnings <- message.handler(warnings, paste("Error: ", models[[i]]$message, " (Model number: ", i, ")", sep = ""))
models[[i]] <- NA
}else if(models[[i]]$ddf$ds$converge != 0){
warnings <- message.handler(warnings, paste("The following model failed to converge: ", i, sep = ""))
models[[i]] <- NA
}else if(any(predict(models[[i]])$fitted < 0)){
warnings <- message.handler(warnings, paste("Negative predictions for model ", i,", excluding these results."), sep = "")
ddf.result <- NA
}
if(!is.null(W)){
warnings <- message.handler(warnings, paste(W, " (Model number: ", i, ")", sep = ""))
}
if(class(models[[i]]) == "dsmodel"){
IC[i] <- switch(analysis@criteria,
"AIC" = AIC(models[[i]])$AIC,
"AICc" = AICc(models[[i]]),
"BIC" = BIC(models[[i]]))
}
IC
length(IC)
min.IC <- min(IC, na.rm = TRUE)
index <- which(IC == min.IC)
min.model <- models[[index]]
index
min.model$ddf
library(dsims)
ds.analysis.sel <- make.ds.analysis(dsmodel = list(~1, ~size, ~size+sex),
key = rep("hn",3),
truncation = 25)
best.model <- analyse.data(ds.analysis.sel, data.obj = survey)
best.model$model$ddf
library(dsims)
ds.analysis.sel <- make.ds.analysis(dsmodel = list(~1, ~size, ~size+sex),
key = rep("hn",3),
truncation = 25)
best.model <- analyse.data(ds.analysis.sel, data.obj = survey)
ds.analysis.sel <- make.ds.analysis(dsmodel = list(~1, ~size, ~size+sex),
key = rep("hn",3),
truncation = 25)
best.model <- analyse.data(ds.analysis.sel, data.obj = survey)
best.model[[1]]
best.model[[1]][[1]]$ddf
best.model[[1]][[2]]$ddf
test <- Distance::ds(survey@dist.data,
truncation = 25,
key = "hn",
formula = ~size)
test$ddf
test <- Distance::ds(survey@dist.data,
truncation = 25,
key = "hn",
formula = ~size+sex)
test$ddf
design
design@region
?dssd::transects
?dssd::generate.transects
ls()
class(transects)
class(transects) == "Line.Transect"
ls()
ds.model$model$ddf
ds.model$model$dht
install.packages("pbapply")
37.99/2
do.something <- function(x){
return(x^2)
}
do.something(10)
10 %>%
do.something
library(ggplot2)
library(dplyr)
10 %>%
do.something
setwd("~/Documents/Work/CAPOD/GLMs")
df <- read.csv("NystedFarmsAnalysis.csv")
alpha <- 0.05
z_alpha_2 <- abs(qnorm(alpha/2)) # z_{alpha/2}
z_alpha_2
head(stats)
head(df)
stats <- df %>%
group_by(Phase) %>%
summarise(Mean=mean(Count),
Var=var(Count),
N=n(),
CI=z_alpha_2*sqrt(Var/N))
stats
ggplot() +
# All locations of segments
geom_point(aes(x=XPos, y=YPos),
colour='lightgrey', data=df)
ggplot() +
# All locations of segments
geom_point(aes(x=XPos, y=YPos),
colour='lightgrey', data=df) +
# Locations where Count > 0 (i.e. birds detected)
geom_point(aes(x=XPos, y=YPos, size=log(Count)),
colour='blue', data=subset(df, Count>0))
ggplot() +
# All locations of segments
geom_point(aes(x=XPos, y=YPos),
colour='lightgrey', data=df) +
# Locations where Count > 0 (i.e. birds detected)
geom_point(aes(x=XPos, y=YPos, size=log(Count)),
colour='blue', data=subset(df, Count>0)) +
# No background colour
theme_bw()
ggplot() +
# All locations of segments
geom_point(aes(x=XPos, y=YPos),
colour='lightgrey', data=df) +
# Locations where Count > 0 (i.e. birds detected)
geom_point(aes(x=XPos, y=YPos, size=log(Count)),
colour='blue', data=subset(df, Count>0)) +
# No background colour
theme_bw() +
theme(panel.grid.major=element_blank(),
panel.grid.minor=element_blank())
# Figure 2
ggplot() +
# All locations of segments
geom_point(aes(x=XPos, y=YPos),
colour='lightgrey', data=df) +
# Locations where Count > 0 (i.e. birds detected)
geom_point(aes(x=XPos, y=YPos, size=log(Count)),
colour='blue', data=subset(df, Count>0)) +
# No background colour
theme_bw() +
theme(panel.grid.major=element_blank(),
panel.grid.minor=element_blank()) +
# Length of one unit on x-axis is equal to one unit on y-axis
coord_equal()
ggplot() +
# All locations of segments
geom_point(aes(x=XPos, y=YPos),
colour='lightgrey', data=df) +
# Locations where Count > 0 (i.e. birds detected)
geom_point(aes(x=XPos, y=YPos, size=log(Count)),
colour='blue', data=subset(df, Count>0)) +
# No background colour
theme_bw() +
theme(panel.grid.major=element_blank(),
panel.grid.minor=element_blank()) +
coord_equal()
ggplot(stats, aes(x=Phase, y=Mean, colour=Phase)) +
geom_errorbar(aes(ymin=Mean-CI, ymax=Mean+CI), size=1) +
geom_point(size=4) +
geom_text(aes(x=Phase, y=Mean+1.2*CI, label=paste0('N=', N))) +
ylab("Counts")
alpha <- 0.05
z_alpha_2 <- abs(qnorm(alpha/2)) # z_{alpha/2}
stats <- df %>%
group_by(YearMonth, Phase) %>%
summarise(Mean=mean(Count/Area),
Var=var(Count/Area),
N=n(),
CI=z_alpha_2*sqrt(Var/N))
# Check values
stats
ggplot(stats, aes(x=YearMonth, y=Mean, colour=Phase)) +
geom_errorbar(aes(ymin=Mean-CI, ymax=Mean+CI), size=1) +
geom_point(size=2) +
theme(axis.text.x=element_text(angle=90)) +
ylab("Abundance per unit area") +
xlab("Year/Month")
library(gridExtra) # to arrange ggplots in a grid
for (covariate in c("XPos", "YPos", "Depth", "DistCoast")) {
p[[covariate]] <- ggplot(df, aes_string(x=covariate,
y="Count/Area")) +
geom_point(alpha=1/2) +
ylab("Abundance per unit area")
}
p <- list()
for (covariate in c("XPos", "YPos", "Depth", "DistCoast")) {
p[[covariate]] <- ggplot(df, aes_string(x=covariate,
y="Count/Area")) +
geom_point(alpha=1/2) +
ylab("Abundance per unit area")
}
p
grid.arrange(grobs=p)
grid.arrange(grobs=p)
library(fields)
quilt.plot(df$XPos, df$YPos, df$DistCoast, nx=35, ny=35,
xlab="XPos", ylab="YPos", asp=1)
library(fields)
quilt.plot(df$XPos, df$YPos, df$DistCoast, nx=35, ny=35,
xlab="XPos", ylab="YPos", asp=1)
quilt.plot(df$XPos, df$YPos, df$Depth, nx=35, ny=35,
xlab="XPos", ylab="YPos", asp=1)
par(mfrow=c(2,2))
# Phase A
quilt.plot(df$XPos[df$Phase=="A"], df$YPos[df$Phase=="A"],
df$Count[df$Phase=='A']/df$Area[df$Phase=='A'], pch=20,
main="Phase A", xlab="X co-ordinate", ylab="Y co-ordinate",
nrow=20, ncol=20, asp=1)
# Phase B
quilt.plot(df$XPos[df$Phase=="B"], df$YPos[df$Phase=="B"],
df$Count[df$Phase=='B']/df$Area[df$Phase=='B'], pch=20,
main="Phase B", xlab="X co-ordinate", ylab="Y co-ordinate",
nrow=20, ncol=20, asp=1)
# Phase C
quilt.plot(df$XPos[df$Phase=="C"], df$YPos[df$Phase=="C"],
df$Count[df$Phase=='C']/df$Area[df$Phase=='C'], pch=20,
main="Phase C", xlab="X co-ordinate", ylab="Y co-ordinate",
nrow=20, ncol=20, asp=1)
# Reset plot window
par(mfrow=c(1,1))
# Reset plot window
par(mfrow=c(1,1))
ggplot() +
geom_point(aes(x=XPos, y=YPos), colour='lightgrey', data=df) +
geom_point(aes(x=XPos, y=YPos, size=log(Count/Area)),
colour="#377eb8", data=subset(df, Count>0)) +
scale_size(range=c(1,3)) +
theme_bw() +
theme(panel.grid.major=element_blank(),
panel.grid.minor=element_blank()) +
coord_equal() +
facet_wrap(~Phase, nrow = 3)
ggplot() +
geom_point(aes(x=XPos, y=YPos), colour='lightgrey', data=df) +
geom_point(aes(x=XPos, y=YPos, size=log(Count/Area)),
colour="#377eb8", data=subset(df, Count>0)) +
scale_size(range=c(1,3)) +
theme_bw() +
theme(panel.grid.major=element_blank(),
panel.grid.minor=element_blank()) +
coord_equal() +
facet_wrap(~Phase, nrow = 3)
ls()
do.something <- function(x){
return(x^2)
}
do.something(10)
10 %>%
do.something
# Load libraries for plotting
library(ggplot2)
library(dplyr)
setwd("~/Documents/Work/CAPOD/GLMs")
df <- read.csv("NystedFarmsAnalysis.csv")
# Figure 2
ggplot() +
# All locations of segments
geom_point(aes(x=XPos, y=YPos),
colour='lightgrey', data=df) +
# Locations where Count > 0 (i.e. birds detected)
geom_point(aes(x=XPos, y=YPos, size=log(Count)),
colour='blue', data=subset(df, Count>0)) +
# No background colour
theme_bw() +
theme(panel.grid.major=element_blank(),
panel.grid.minor=element_blank()) +
coord_equal()
alpha <- 0.05
z_alpha_2 <- abs(qnorm(alpha/2)) # z_{alpha/2}
stats <- df %>%
group_by(Phase) %>%
summarise(Mean=mean(Count),
Var=var(Count),
N=n(),
CI=z_alpha_2*sqrt(Var/N))
ls()
library(DSsim)
library(testthat)
devtool::load_all()
library(testthat)
devtools::load_all()
library(testthat)
setwd("~/Documents/GitHub/dsims/dsims")
devtools::load_all()
library(testthat)
devtools::load_all()
library(testthat)
